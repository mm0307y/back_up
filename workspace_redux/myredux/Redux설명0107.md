문제 정의 - 어떤 코드가 상태를 어디서 바꾸나?
웹 어플리케이션을개발한다라고 하면
기본적으로 상태 즉 데이터를 어떤 유형의 UI로 가공하는가 라고 하는게 핵심적인 문제인것 같아요
거의 대부분의 코드가 그것을 위해서 만들어져 있기도 하고요
또 리액트라고 하는 라이브러리도 결국 데이터를 어떻게 UI로
즉 DOM으로 잘 변형할 것인가 라고 하는 문제를 다루고 있죠
그 만큼 상태는 어플리케이션에 있어서 굉장히 중요한 위치를 차지하고 있는데요
문제는 이 상태를 관리하는게 굉장히 까다롭다는 거죠

어플리케이션의 규모가 커지면 커질 수록 상태 관리는 굉장히 중요한 화두로 떠 오릅니다
그래서 상태만 전문적으로 다루는 라이브러리들이 굉장히 많고
우리가 어떻게 하면 상태를 잘 다룰 것인가라고 하는 부분들을
굉장히 고민을 많이 하는 주제 중의 하나 입니다

One way(단방향 데이터 흐름) - flux 아키텍쳐
데이터 즉 상태가 있을 때 그 상태를 UI와 연결을 시켜 놓으면 데이터와 UI가
서로 상호작용하여 데이터가 변하면 UI가 바뀌고
UI가 바뀌면 데이터도 바뀌는 이런식의 Two Way Binding을 angular.js가 제공했다

Two way binding의 문제 제시
데이터를 여러 개의 UI랑 연결했을 때 상태도 많아지고 연결된 UI도 많아지면서
상태가 바뀌었는데 뭔가 잘못 바뀌었어요
그런데 그게 어느 UI와 연결되어서 바뀌었는지 잘못 바뀌었는지
알수가 없고 찾기도 힘들고 성능도 떨어지고 여러가지 문제점이 복합적으로 발생함

그런 상태에서 페이스북에서 리액트가 나왔고 처음에는 상태 관리와 관련된 기능은
제공하지 않았고 그런데 어플리케이션을 관리하는데 상태 관리를 빼고 한다는 건
말이 안되잖아요

그래서 리액트는 One way binding 라는 아이디어로 상태관리를 하게 되었다
데이터가 한 쪽 방향으로만 흐른다 그래서 One way 아키텍쳐라고 부른다

Action -> Dispatcher -> Store -> View

데이터를 왜 상태라고 부르죠? 내용물이 자꾸 바뀌니까 상태라고

혈액형은 변하지 않으니까 상태라고 하지 않지만
기분은 상황에 따라서 바뀌니까 상태라고 합니다
데이터가 상황에 따라서 바뀌니까 상태라고 한다
기분 안에 들어있는 내용물이 자꾸 바뀌기 때문에 우리가 상태라고 부르는 거예요

상태는 그래서 자꾸 바뀐다
그런데 어떻게 바뀔 거야 라고 하는게 중요하겠죠

바뀌는 것을 제어하는 것이 Action 과 Dispatcher 라고 하는 겁니다

무슨 데이터를 어떻게 바꿀거야 라는 시그널이 나가야 되겠죠
그 시그널이 Action 이라고 하는 거고요
그 Action을 Store 에 보내기 위해서 즉 데이터가 여기 Store라고 하는 곳에만 있으니까
Dispatcher라고 하는 도구를 이용해서 보낸다

내용물은 Action이고 이런 뜻입니다
View에서 Store로 가는 방향이 없고
View에서 Dispatcher로 직접가는 방향이 없다

Flux 아키텍쳐란
One way 한 방향으로 데이터가 흐르게 할 수 있는 아키텍쳐에 대한 아이디어임

store는 상태 묶음이다.
즉 Store가 있으면 이 Store가 View 즉 UI의 컴포넌트로 흘러갈 텐데
UI의 콤포넌트한테 Store를 그대로 주면 어떤게 문제가 되요
최초의 문제 제기했던 상태를 Component가 직접적으로 제어하게 되는
문제들이 생기니까 해결책으로 갈 수 없는 거죠
그래서 UI한테는 그 상태를 직접적으로 주지 않을 거예요
그래서 리턴하는 것에는 이 State를 넘겨주지 않습니다

    그러면 return(3번라인)하는 객체한테는 뭘 넘겨줘야 할까요.

    일단 이 걸 먼저 생각해 보죠.
    상태는 이 createStore 함수 안에 있죠.
    이 state(2번라인)라는 것으로 있다.
    그리고 이 State를 다루게 될 즉 변경하거나 읽거나 하는 코드들 UI의 Component 들이 될 텐데
    이 Component들은 당연히 createStore 바깥쪽에 있을 거예요
    그러면 바깥쪽에 있는 곳에서 이 State를 직접적으로 접근하지 못하는데
    어떻게 수정할 것인가?

    결국은 수정할 수 있는 방법을 이 createStore가 제공을 해줘야 하는 거죠
    어떻게 제공을 하면 될까요
    여기서 문제가 하나 있어요.
    제공을하면 되는데 즉 제공을 한다
    createStore가 상태를 변경하는 것을 제공한다? 제공하는게 무슨 애기죠
    제공한다는 건 결국 createStore가 state의 내용을 알고 있다는 전제가 있어야 가능한 거잖아요
    이런 상태가 있으니까 이 상태를 이렇게 바꾸려고 하려면 이런 도구를 줄테니
    네가 이 도구를 가지고 바꿔 이런 건데 그러면 결국 createStore가 state의 구조를 안다는 애기인데
    그런데 어떻게 createStore가 그 수많은 다양한 어플리케이션의 상태 구조를 알 수 있을까요
    근본적으로 알 수가 없는 거죠

    그럼 누가 상태의 구조를 알고 있죠
    어플리케이션의 개발자가 상태의 구조를 알고 있죠
    그래서 어플리케이션 개발자들이 상태를 변경하는 로직을 작성해야 합니다.

    그러면 그 로직을 한 번 작성해 보죠

return 이런식으로 return {...state} 부분을 말함
이렇게 하면 새로운 객체가 만들어져서 return을 하게 되고
이렇게 return 된 객체는 당연히 있죠

    worker의 return값으로 오니까 위쪽에 있는 state를 이렇게 업데이트를 해주면
    항상 이 state가 새로운 객체로 overwrite 되는 구조를 만들 수가 있는 거죠
    상태 디자인이 two depth 이상으로 깊어지는 것을 리덕스는 지양하고 있다.
    two depth 이상으로 상태 디자인을 하게 되면 deep copy를 해야 되고
    deep copy되는 구조를 만들어야 되니까 조금 번거로운데 일단 디테일한 부분은 현재 관심사는 아니다

    이제 조금 더 구체적인 상태를 디자인 해 보도록 하자
    어떤 상태를 내가 가질 것인가 라고 하는 생각을 해 볼 수 있겠죠
    상태를 어디서 어떻게 만들까요
    이 코드가 실행되는 흐름을 한 번 살펴보면
    이렇게 쭉 흘러와서 send를 호출하면 send로 가서 worker를 호출하고
    worker의 state 현재는 undefined가 들어 있겠죠. state에
    그러면 이렇게 들어가서 그냥 복사해서 넘어가는데 당연히 실행하면 에러가 날것이다
    여기는(worker함수의 파라미터가 state인데 이것을 말함) 객체가 아니라 undefined이니까요

    그래서 이걸 방어 코드를 한 번 작성해 볼까요
    state가 아무것도 안 들어오면 default값으로 객체로 만들자 -> state = {}로 변경함함
    그런데 여기에 store의 send 를 할 때 state의 상태가 여러개가 있을 거잖아요.

    그중에 뭘 하나 바꿀거다. 어떤 걸 바꿀 거다 이런 시그널이 있어야 겠죠
    그래서 내가 어떤 상태를 하나 만들어 볼거다. 어떤 상태를 만들거냐 이상태의 count라고 하는
    속성을 하나 만들고 그 count 값을 1씩 증가하는 걸 한 번 만들어 보죠
    (worker함수의 파라미터 자리를 말하고 있음)
    여기에 먼저 count라고 하는 속성을 한 번 만들어 보자
    function worker(state = { count: 0 })
    한 번에 간단하게 이 state가 객체가 되겠죠
    그러면 send하면 count는 0이 될 거예요.
    그런데 할 때 마다 이 count값이 즉 send 를 할 때마다
    count값이 늘어나야 되니까 여기 코드가 좀 바뀌어야 겠죠
    (return {...state} 부분을 말하고 있음.)
    복사를 해야 되니까 state를 펼쳐 놓은 건 그대로 두고요
    count말고 다른 곳도 있을 수 있으니까
    return {...state, count: state.count + 1 } 이라고 고친다.
    count+1 하면 이제 1씩 증가가 되는 값이 되겠죠
    이렇게 되면 기본 틀이 잡힙니다.
    그러면 send할 때 마다 state안에 있는 count라고 하는 속성이 1씩 증가하는 식이 되겠죠

     이 createStore바깥쪽에서 createStore안에 send함수 안에 worker함수 파라미터
    state값을 읽어와야 되잖아요. 읽어와야 써먹죠
    왜냐 안쪽에만 있으니까 지금 읽을 수가 없어요. 읽을 방법이 없다

    그러면 당연히 return에서 이 send함수를 제공한 것처럼
    이 값을 읽을 수 있는 함수도 제공을 해줘야 되겠죠
    이것을 만들어 볼께요.

    function getState(){
        return state; //16
    }
    그러면 값을 읽고 싶을 땐 이렇게 하면 되겠죠
    store.getState() //17
    이것을 콘솔 로그에 한 번 찍어 보자

    이것이 redux의 핵심 코드이다.
    현재 까지 작성한 코드 안에서 문제점들을 한 번 찾아볼께요
    먼저 눈에 띄는 문제는 이 getState()를 쓰고 있는데 데이터를 읽기 위해서
    getState라고 하는 함수를 쓰고 있는데 문제는 뭐냐 하면 데이터가 언제 바뀌었는지
    알고 있어야 이런 식으로 코드를 쓸 수 있는 거죠
    데이터가 언제 바뀌었어. 예를 들면 지금은 하나의 코드 안에서 전개 되기 때문에
    이렇게 써도 되겠지만 컴포넌트가 여러 개 있는 상황에서 어떤 컴포넌트가 데이터를
    바꿨는지 즉 store에 send를 호출했어. 그럼 데이터가 바뀌었죠.
    그런데 다른 component에서 그 데이터가 바뀐지 어떻게 알고 getState를 호출할 까요
    그건 불가능하겠죠. 그래서 이런 방법으로는 데이터가 바뀌었다는 걸 인지하고 데이터를
    읽을 타이밍을 잡기가 어렵습니다.

    그래서 그런 부분들을 제공을 해줘야 되는데 거기에 바로 구독 발행 모델을 도입할 수 있습니다.
    구독 발생 모델(Pub and Subscribe) 라고 하는데 일종의 패턴이죠
    내가 어떤 함수를 줄테니 즉 구독할 테니 데이터가 바뀌면 그 함수를 호출해줘
    이것을 코드로 구현하려면
    일단 외부로 부터 함수를 받아야 겠죠. 그리고 여러 개의 함수가 구독을 할 수 있을 테니
    당연히 그 구독 함수들을 배열에 저장해 놓으면 되겠죠
    그래서 그 구독기들을 handlers라고 한 번 해 볼게요.
    handlers를 빈 배열 하나 만들어 놓고 그리고 이 handlers의 함수를 등록하는
    구독기를 하나 제공해 줘야 겠죠
    subscribe 라는 정도의 이름을 한 번 써 볼까요.

    function subscribe(handler){
        handlers.push(handler)
    }

    store.subscribe((state) => {//23
        console.log(store.getState())//24
    }//25

    데이터가 바뀔 때마다 이 구독기가 호출이 되어질 테니까

    이제 마지막 마무리 하나만 더 추가하면 이 코드가 완성됩니다.
    마지막 남은 문제점 뭘까요
    이것이 Redux의 상태 관리자 Library인 Redux란 말인가
    하는 생각이 들 정도인데 어떤 문제가 있을까요
    send 호출하는 부분들이 문제예요. 어떤 문제가 있죠
    worker에다가 내가 뭘 바꿀거야 라고 하는 의미로 send를 하는데
    뭘 바꾸는지는 전혀 알려주고 있지 않죠
    그냥 send하면 무조건 count로 1씩 증가하는 허무맹랑한 코드로
    되어 있는데 Action이라고 하는 박스가 기억나세요.
    바로 그 Action이라고 하는 박스가 이 worker 한테 전해주는
    뭘 바꿔 라고 하는 힌트를 담고 있는 객체를 의미함.
    그래서 Action을 받아야 돼요 이것은 어떤 테크닉이라기 보다는 Redux가 만들어 놓은
    컨벤션(관습,조약)입니다 . 이렇게 하자라는 약속이다.
